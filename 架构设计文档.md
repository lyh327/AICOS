# AICOS 架构设计文档

本文档面向开发与产品团队，描述项目主要模块、接口契约、数据结构、错误模式、测试策略与部署建议，便于后续维护和扩展。

## 1. 总体架构概览

AICOS 是一个基于 Next.js（App Router） + TypeScript 的前端与后端同构应用，主要模块包括：

- 前端页面与 UI 组件（Next.js 客户端组件）
- 后端 API 路由（Next.js API Route）
- 服务层（LLM、语音、会话存储等）
- 数据层（内置角色数据、会话/本地存储）

高层数据流：
用户（文本/语音）→ 前端 UI → 调用 `/api/chat` → `LLMService` （请求外部 GLM-4.5）→ 返回并持久化消息 → 前端渲染

## 2. 项目团队与分工

本项目为个人独立开发项目。

- **核心开发**：骆源浩（全栈开发）
- **职责范围**：负责所有模块的设计、编码、测试与部署，涵盖前端、后端、服务集成与运维。

## 3. 代码树（关键文件/目录）

- `src/app/chat/[id]/page.tsx` — 聊天主界面（客户端）
- `src/app/api/chat/route.ts` — 聊天后端 API 路由（Next Request/Response）
- `src/services/llm.ts` — GLM 调用封装（基础对话功能）
- `src/services/character-manager.ts` — 角色数据管理
- `src/services/session-storage.ts` — 本地会话持久化（SessionStorage）
- `src/data/characters.ts` — 预设角色数据
- `src/types/index.ts` — 全局类型定义（Character、ChatMessage、ChatSession 等）
- `src/components/` — 全局可复用 UI 组件

## 4. 模块规格（接口 / 责任 / 数据契约）

下面按模块列出精确的契约（Inputs / Outputs / 错误模式 / 成功标准）。

### 4.1 后端服务与 API

#### 4.1.1 `LLMService`（`src/services/llm.ts`）

- **职责**：封装与外部 GLM-4.5 模型的交互，提供标准化的对话生成与续写功能。
- **主要方法**：
  - `generateResponse(character, userMessage, conversationHistory)`: 基础对话，调用 GLM-4.5 模型。
  - `continueResponse(character, previousContent, conversationHistory)`: 继续生成被截断的回复。
- **输出契约** (`Promise<LLMResponse>`)：
  ```ts
  interface LLMResponse {
    content: string;
    success: boolean;
    error?: string;
    isComplete?: boolean; // 是否完整
    finishReason?: string; // 'stop'|'length'|'sensitive'|'tool_calls'
  }
  ```
- **错误模式**：
  - API 调用失败：返回 `success: false` 与 `error` 文本。
  - 未返回 `content`：视为错误，由上层处理。
- **成功标准**：成功返回内容并设置正确的完成状态 `isComplete`。

#### 4.1.2 API 路由 `/api/chat`（`src/app/api/chat/route.ts`）

- **职责**：作为前端与 `LLMService` 的网关，负责入参校验、速率限制，并调用 `LLMService` 返回结构化 JSON。
- **输入契约** (JSON Body)：
  ```json
  {
    "characterId": "string",
    "character": "Character", // 可选，用于自定义角色
    "message": "string", // 基础对话时必填
    "conversationHistory": "{ role: 'user'|'assistant', content: string }[]",
    "continueMessageId": "string", // 续写时使用
    "previousContent": "string" // 续写时使用
  }
  ```
- **输出契约** (JSON Response)：
  ```json
  {
    "content": "string",
    "success": "boolean",
    "isComplete": "boolean",
    "finishReason": "string",
    "character": "{ id, name, avatar }"
  }
  ```
- **错误与约束**：
  - 缺少 `characterId` 或 `message`（且非续写模式）时，返回 400 Bad Request。
  - 角色不存在时，返回 404 Not Found。
  - 请求频率超限时，返回 429 Too Many Requests。

### 4.2 前端核心模块

#### 4.2.1 `ChatPage`（`src/app/chat/[id]/page.tsx`）

- **职责**：管理聊天界面的核心状态、用户交互与消息流。
- **核心状态**：
  - `messages: ChatMessage[]`: 当前会话的消息列表。
  - `currentSession: ChatSession | null`: 当前会话的元数据。
  - `isLoading: boolean`: 标记是否正在等待后端响应。
- **数据结构** (`ChatMessage`):
  ```ts
  interface ChatMessage {
    id: string;
    type: 'user' | 'character';
    content: string;
    timestamp: Date;
    isComplete?: boolean; // 消息是否完整
    canContinue?: boolean; // 是否可续写
  }
  ```
- **交互契约**：
  - 发送消息时，构造 `conversationHistory`（最近6轮）并 POST 至 `/api/chat`。
  - 接收响应后，更新 `messages` 列表并渲染。
  - 处理加载状态，为用户提供明确的反馈。

#### 4.2.2 `CharacterManager` 与相关组件

- **服务** (`src/services/character-manager.ts`):
  - **职责**: 提供角色的增删改查（CRUD）功能，管理预设角色和用户自定义角色。
  - **主要方法**: `getCharacters()`, `getCharacterById(id)`, `createCharacter(character)`, `updateCharacter(character)`, `deleteCharacter(id)`。
- **UI 组件**:
  - `CharacterSearch` (`src/components/CharacterSearch.tsx`): 提供角色搜索和筛选功能。
  - `CharacterForm` (`src/components/CharacterForm.tsx`): 用于创建和编辑角色信息的表单。
  - `CharacterCard` (`src/components/CharacterCard.tsx`): 以卡片形式展示单个角色的摘要信息。

### 4.3 数据持久化

#### 4.3.1 `SessionStorageService`（`src/services/session-storage.ts`）

- **职责**：在浏览器端将会话数据持久化到 `localStorage`，提供完整的会话管理能力。
- **主要方法**：
  - `createSession(characterId, messages)`
  - `addMessage(sessionId, message)`
  - `getSession(sessionId)`
  - `listSessions()`
  - `removeSession(sessionId)`
- **导出功能**：支持按会话导出为 JSON 或 Markdown 格式，包含完整的会话元数据和消息历史。

### 4.4 其他服务

#### 4.4.1 `VoiceService`（`src/services/voice.ts`）

- **职责**：封装 ASR (语音识别) 和 TTS (语音合成)，优先使用 Web Speech API。
- **接口示例**：
  - `ASRService.startRecording(onResult, onEnd, onError)`
  - `TTSService.speak(text, options)`
- **错误模式**：若浏览器不支持，则禁用语音功能并向用户提供文本输入作为备选。

## 5. 设计决策与说明

- **简化对话模式**：专注于核心的 LLM 对话体验，剥离复杂功能。
- **错误与降级策略**：
  - LLM API 出错：记录详细日志，向用户返回友好的错误提示。
  - TTS/ASR 不可用：优雅降级，确保核心文本交互功能不受影响。
- **性能与安全**：
  - 后端 API 实现速率限制，防止恶意请求。
  - 严禁在前端或日志中暴露 API Key。
  - 对用户输入进行长度限制，防止超量消耗。

## 6. 测试计划

- **单元测试** (服务层):
  - `LLMService`: 测试基础对话和错误处理。
  - `SessionStorageService`: 测试 CRUD 操作和数据一致性。
  - `CharacterManager`: 测试角色管理功能。
- **集成测试** (端到端):
  - 完整消息流：前端发送消息 → `/api/chat` → 返回回复并正确渲染。
  - 角色创建与使用：通过 `CharacterForm` 创建新角色，并用其发起对话。
- **手动测试**:
  - UI 与交互：测试所有核心交互，如发送消息、切换会话、创建角色。
  - 导出功能：验证导出的 JSON/Markdown 文件格式与内容的完整性。

## 7. 导出会话功能实现建议

- **需求**：用户能够从会话列表中选择一个或多个会话，并将其导出为 JSON 或 Markdown 文件。
- **实现要点**：
  1. 在 `会话列表` 页面增加 `导出` 按钮，点击后打开 `SessionExportDialog` 组件。
  2. `SessionExportDialog` 通过 `SessionStorageService.listSessions()` 获取所有会话，并以列表形式展示，支持多选。
  3. 提供导出格式选项：`JSON`（原始结构）和 `Markdown`（人类可读）。
  4. 导出时，构造所选数据，通过 `Blob` 和 `URL.createObjectURL` 生成文件并触发浏览器下载。

## 8. 部署与监控

- **部署**：将应用部署到 Vercel 或自托管的 Node.js 环境。
- **环境管理**：使用 `.env.local` 管理环境变量，严禁将敏感信息提交至代码仓库。
- **监控**：
  - 生产环境关闭 Debug 日志，集成 Sentry 或 Datadog 等工具进行错误监控。
  - 统计 LLM 请求的 Token 消耗、错误率和响应延迟，用于成本控制和性能优化。